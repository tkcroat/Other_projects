# -*- coding: utf-8 -*-
"""
Created on Sun Mar  5 16:17:02 2017

@author: tkc
"""

import pickle
import os.path
from googleapiclient.discovery import build
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
import pygsheets as pyg
from datetime import datetime
import pandas as pd
import numpy as np

path='C:\\Users\\tkc\\Documents\\Fin\\credit_card_bills\\'


def convertDate(val):
    # general convert date 
    try:
        return datetime.strptime(val,'%m/%d/%Y')
    except:
        try:
            return datetime.strptime(val,'%m/%d/%y')
        except:
            print("Failed conversion of %s" %val)
            return val

def loadProcessCC(ccPath, **kwargs):
    ''' process and sync cols for different CC accts (from csv)
    kwargs={'Acct':1037}
    '''
    df=pd.read_csv(ccPath)
    mycols=['Date', 'Acct','Description', 'Amount', 'Category', 'Matched', 'Notes']
    df=df.rename(columns={'Card':'Acct','Transaction Date':'Date','Trans. Date':'Date'
            ,'Memo':'Notes'})
    df['Matched']=''
    if 'Acct' not in df.columns and 'Acct' in kwargs:
        df['Acct']=kwargs.get('Acct')
    missing=[i for i in mycols if i not in df.columns]
    for col in missing:
        df[col]=''
    df=df[mycols]
    # convert date
    def convDate(val):
        try:
            return datetime.strptime(val,'%m/%d/%Y')
        except:
            print("Failed conversion of %s" %val)
            return val
    df['Date']=df['Date'].apply(lambda x:convDate(x))  
    return df

def combineCCBills(CClist):
    ''' Combine CC bills csv files to single df
    args:
        CClist - list of dataframes already loadprocessed
    '''
    df=pd.DataFrame()
    for cc in CClist:
        df=df.append(cc, ignore_index=True)
    df=df.sort_values(['Date','Description'])
    return df

def readAptExp(sheetID, tokenFile):
    ''' Read apt expense google sheet (online version)
    '''
    def convFloat(val):
        try:
            return round(float(val),2)
        except:
            return np.nan
        
    def convDate(val):
        try:
            return datetime.strptime(val, '%m/%d/%Y')
        except:
            try:
                return datetime.strptime(val, '%m/%d/%y')
            except:
                try:
                    return datetime.strptime(val.split(' ')[0], '%Y-%m-%d')
                except:
                    print('Error converting', val)
                    return val
    
    myPygSheet, df = readGsheet(sheetID, tokenFile) # call generic reader
        
    df['Date']=df['Date'].apply(lambda x: convDate(x))
    for col in df.columns:
        if col in ['Amount','Repairs','Improvement','Supplies','Other','Home repair','Diff']:
            df[col]=df[col].apply(lambda x: convFloat(x))
    df=df[df['Vendor']!='']
    df=df[pd.notnull(df['Vendor'])]
    return myPygSheet, df

def getGoogleCreds(tokenFile):
    ''' Load and process credentials.json (generated by Google API)
    Enables creation of google Service object to access online google sheets
    TODO:  copy over credentials json
    '''

    creds = None
    # The file token.pickle stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists(tokenFile):
        with open(tokenFile, 'rb') as token:
            creds = pickle.load(token)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(cnf._INPUT_DIR +
                '\\credentials.json', SCOPES)
            creds = flow.run_local_server(port=0)
        # Save the credentials for the next run
        with open(tokenFile, 'wb') as token:
            pickle.dump(creds, token)
    return creds

def readGsheet(sheetID, tokenFile):
    ''' Read google sheets online and return as dataframe
    and as pygsheet
    args:
        sheetID - google sheet ID
        tokenFile - 
    
    '''
    creds = getGoogleCreds(tokenFile) # google.oauth2.credentials
    gc = pyg.authorize(custom_credentials=creds) # pygsheets client
    sh = gc.open_by_key(sheetID)
    myPygSheet=sh[0]
    mycols=myPygSheet.get_row(1) # gets column names
    df=pd.DataFrame(myPygSheet.get_all_records())
    mycols=[i for i in mycols if i!='']
    df=df[mycols] # reorder cols 
    return myPygSheet, df

#%% Apartment expenses tax scripts

def sumByUnits(Aptexp, units, cols):
    ''' Summarize expenses by groups of units ... 
    
    args:
        Aptexp - loaded expenses (repair/improve) from annual xls file
        units -  dict w/ name and list of units in given unit group
    '''
    summlist=[]
    for groupName in list(units.keys()):
        summdict={}
        thisUnits=units.get(groupName,[])
        summdict['group']=groupName
        thisExp=Aptexp[Aptexp['Unit'].isin(thisUnits)]
        for col in cols:
            summdict[col]=thisExp[col].sum()
        summlist.append(summdict)
    summs=pd.DataFrame(summlist)
    return summs
        
    
def loadexpenses(year, CCfiles):
    ''' Load CC bills & apt expenses for given year
    CCfiles -dict w/ num key and path
    '''
    Aptexp=pd.read_excel('C:\\Users\\tkc\\Documents\\Fin\\taxes\\apt_expenses'+str(year)+'.xlsx', skiprows=1)
    Aptexp=Aptexp.iloc[:,0:12]
    mycols=['Date','Acct','Vendor','Comments','Amount','Repair','Improve','Supplies',
            'Other','Home','Unit','Receipt']
    Aptexp.columns=mycols
    Aptexp=Aptexp.dropna(subset=['Acct'])  
    Aptexp.Acct=Aptexp.Acct.astype(str) # accts as string for comparison
    # now load credit card bill Excel files
    mycols=['Date','Vendor','Amount','Category','Subtotals','Comments','Included']
    CCbill=pd.DataFrame(columns=mycols)
    start=datetime.strptime('1/1/'+str(year), '%m/%d/%Y')  
    end=datetime.strptime('12/31/'+str(year), '%m/%d/%Y')  
    
    for key, val in CCfiles.items():
        try:
            thisCC=pd.read_excel(val)
        except:
            print("can't load file", val)
            continue
        thisCC=thisCC.iloc[:,0:7]
        thisCC.columns=mycols
        # filter to those containing APT
        thisCC=thisCC[pd.notnull(thisCC['Category'])]
        thisCC['Category']=thisCC['Category'].apply(lambda x:makeStr(x))            
        try:
            thisCC['Date']=thisCC['Date'].apply(lambda x:makeDt(x))
        except:
            print('Problem w/ type conversion for', val)
            continue
        thisCC=thisCC[ thisCC['Category'].str.contains('APT', case=False) ]
        # apply yearly time filter
        thisCC=thisCC[(thisCC['Date'] > start) & (thisCC['Date'] <= end)]
        thisCC['Acct']=key
        CCbill=CCbill.append(thisCC, ignore_index=True)
    return Aptexp, CCbill

def makeStr(val):
    '''
    Convert val to string (useful before str.contains filter)
    '''
    try:
        return str(val)
    except:
        return ''
    
def makeDt(val):
    '''
    Convert val to string (useful before str.contains filter)
    '''
    if isinstance(val, datetime):
        return val
    try:
        return val.to_pydatetime()
    except:
        print('could not convert', val, 'to datetime')
        return np.nan